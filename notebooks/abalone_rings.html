<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.7.33">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Serene Zha, Mehmet Imga, Claudia Liauw, Wendy Frankel">

<title>Predictive Models of the Age of Abalones Based on Physical Characteristics</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for citations */
div.csl-bib-body { }
div.csl-entry {
  clear: both;
  margin-bottom: 0em;
}
.hanging-indent div.csl-entry {
  margin-left:2em;
  text-indent:-2em;
}
div.csl-left-margin {
  min-width:2em;
  float:left;
}
div.csl-right-inline {
  margin-left:2em;
  padding-left:1em;
}
div.csl-indent {
  margin-left: 2em;
}</style>


<script src="abalone_rings_files/libs/clipboard/clipboard.min.js"></script>
<script src="abalone_rings_files/libs/quarto-html/quarto.js" type="module"></script>
<script src="abalone_rings_files/libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="abalone_rings_files/libs/quarto-html/popper.min.js"></script>
<script src="abalone_rings_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="abalone_rings_files/libs/quarto-html/anchor.min.js"></script>
<link href="abalone_rings_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="abalone_rings_files/libs/quarto-html/quarto-syntax-highlighting-ea385d0e468b0dd5ea5bf0780b1290d9.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="abalone_rings_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="abalone_rings_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="abalone_rings_files/libs/bootstrap/bootstrap-81267100e462c21b3d6c0d5bf76a3417.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">


</head>

<body class="fullcontent quarto-light">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">

<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Predictive Models of the Age of Abalones Based on Physical Characteristics</h1>
</div>



<div class="quarto-title-meta">

    <div>
    <div class="quarto-title-meta-heading">Author</div>
    <div class="quarto-title-meta-contents">
             <p>Serene Zha, Mehmet Imga, Claudia Liauw, Wendy Frankel </p>
          </div>
  </div>
    
  
    
  </div>
  


</header>


<section id="summary" class="level2">
<h2 class="anchored" data-anchor-id="summary">Summary</h2>
<p>In this report, we aim to create an effective model which can predict age of Abalone accurately based on individual physical characteristics. We perform exploratory data analysis and visualization, test both linear and non-linear models on our data, then compare models through regression metrics.</p>
</section>
<section id="introduction" class="level2">
<h2 class="anchored" data-anchor-id="introduction">Introduction</h2>
<p>Abalone are marine mollusks that are commercially important in fisheries and aquaculture, particularly in regions such as Tasmania. Estimating the age structure of abalone populations is essential for setting sustainable harvest limits and monitoring stock health. However, the standard method for determining age requires cutting the shell through the cone, staining it, and counting growth rings under a microscope—a destructive, time-consuming, and labor-intensive procedure (<span class="citation" data-cites="pop_biol_paper">W. Nash et al. (<a href="#ref-pop_biol_paper" role="doc-biblioref">1994</a>)</span>). Because of this, methods that can infer age from simple, non-destructive measurements of the animal are of practical interest to biologists, fisheries managers, and growers.</p>
<p>Here, we ask whether we can use a machine learning model to predict the age of an abalone from basic physical measurements. Specifically, we will explore linear regression models in Python (<span class="citation" data-cites="python">Python Core Team (<a href="#ref-python" role="doc-biblioref">2025</a>)</span>) to relate age to various attributes, including sex, shell length, diameter, height, and several weight measurements. To investigate this question, we use the UCI Abalone dataset (<span class="citation" data-cites="abalone_1">S. Nash Warwick and Ford (<a href="#ref-abalone_1" role="doc-biblioref">1994</a>)</span>), which contains 4,177 abalones with eight predictor variables and a target variable, “Rings”. Each row corresponds to one abalone, and the recorded features include sex (male, female, infant), three shell size measurements (length, diameter, height), and four weight measurements (whole, shucked, viscera, and shell weight). The number of rings serves as a proxy for age, with age in years given approximately by Rings + 1.5 [2], to account for any rings missed in counting (they can be difficult to see). By building and evaluating linear regression models on this dataset, we aim to understand how well these readily obtained physical measurements can predict abalone age and what this implies for practical, non-destructive age estimation.</p>
</section>
<section id="methods" class="level2">
<h2 class="anchored" data-anchor-id="methods">Methods</h2>
<p>In this section, we describe the data acquisition, preprocessing steps, and modeling approaches used to predict abalone age from physical measurements. We follow the golden rule of machine learning by splitting our data into training and test sets <strong>before</strong> any exploratory analysis or model fitting, ensuring that our test set remains completely unseen until final evaluation.</p>
<section id="how-we-split-the-data" class="level4">
<h4 class="anchored" data-anchor-id="how-we-split-the-data">How We Split The Data</h4>
<p>Following the <strong>golden rule of machine learning</strong>, we split the data into training (80%) and test (20%) sets <strong>before</strong> performing any exploratory analysis or model fitting. This ensures that our test set remains completely unseen during the entire modeling process, giving us an unbiased estimate of how well our models will generalize to new, unseen abalones. All subsequent exploratory data analysis and visualizations use only the training data.</p>
</section>
<section id="data-validation" class="level3">
<h3 class="anchored" data-anchor-id="data-validation">4. Data Validation</h3>
<p>Before proceeding with analysis, we validate the data quality using Pandera schema validation. This ensures our data meets expected constraints (correct types, reasonable value ranges, no missing values in critical columns) and helps catch any data quality issues early in the pipeline.</p>
<section id="correct-data-file-format" class="level4">
<h4 class="anchored" data-anchor-id="correct-data-file-format">Correct Data File Format</h4>
</section>
<section id="data-validation-using-panderas" class="level4">
<h4 class="anchored" data-anchor-id="data-validation-using-panderas">Data Validation Using Panderas</h4>
</section>
<section id="distribution-of-target" class="level4">
<h4 class="anchored" data-anchor-id="distribution-of-target">Distribution of Target</h4>
<div id="dist_boxplot" class="quarto-figure quarto-figure-center anchored">
<figure class="figure">
<p><img src="../results/data_validation/target_boxplot.png" class="img-fluid figure-img"></p>
<figcaption>Boxplot showing the distribution and outliers of target variable Rings.</figcaption>
</figure>
</div>
<p><strong>Observation</strong>: There are outliers on the high end (older abalones), but no anomalous values below 0 or unreasonably high values. The outliers represent legitimately old abalones rather than data errors.</p>
<div id="rings_hist" class="quarto-figure quarto-figure-center anchored">
<figure class="figure">
<p><img src="../results/data_validation/target_histogram.png" class="img-fluid figure-img"></p>
<figcaption>Histogram showing the distribution of target variable Rings.</figcaption>
</figure>
</div>
<p><strong>Observation</strong>: The distribution shows a slight right skew, with most abalones having between 7-12 rings. This suggests age distribution in the sample is not perfectly normal, which may affect model assumptions.</p>
</section>
<section id="correlations" class="level4">
<h4 class="anchored" data-anchor-id="correlations">Correlations</h4>
<div id="rings_corr" class="quarto-figure quarto-figure-center anchored">
<figure class="figure">
<p><img src="../results/data_validation/correlation_plot.png" class="img-fluid figure-img"></p>
<figcaption>Correlation heatmap showing relationships between numerical features and the target variable (Rings).</figcaption>
</figure>
</div>
<p><strong>Observation</strong>: Features show moderate positive correlations with Rings (0.5-0.6), indicating that physical measurements do contain predictive signal for age. However, there are high correlations among the features themselves (&gt;0.9 between weights and dimensions), suggesting multicollinearity. This could affect linear regression coefficient interpretation, though it doesn’t necessarily harm prediction accuracy. Non-linear models like Random Forest are less sensitive to multicollinearity.</p>
</section>
</section>
<section id="exploratory-data-analysis-eda" class="level3">
<h3 class="anchored" data-anchor-id="exploratory-data-analysis-eda">5. Exploratory Data Analysis (EDA)</h3>
<p>The exploratory analysis below is performed <strong>only on the training set</strong> to avoid any data leakage from the test set. This ensures our understanding of the data and any decisions made based on EDA do not inadvertently incorporate information from the held-out test data.</p>
<div id="eda_prof" class="quarto-figure quarto-figure-center anchored">
<figure class="figure">
<p><embed src="../results/eda/pandas_profiling.html" class="img-fluid"></p>
<figcaption>EDA</figcaption>
</figure>
</div>
<section id="summary-1" class="level4">
<h4 class="anchored" data-anchor-id="summary-1">Summary</h4>
<ul>
<li>Mostly numerical variables except sex.</li>
<li>No missing values.</li>
<li>Target (Rings) ranges from 1 to 29. Mostly normal, slight right skew.</li>
<li>Sex needs to be one-hot encoded, the rest should be scaled.</li>
<li>Numeric variables are moderately positively correlated with target.</li>
</ul>
</section>
<section id="visualisation" class="level4">
<h4 class="anchored" data-anchor-id="visualisation">Visualisation</h4>
<p>Below, we investigate the possible relationship between sex of adults (M/F), Infants, and number of rings, as the relationship may differ between those categories.</p>
<div id="interaction_plot" class="quarto-figure quarto-figure-center anchored">
<figure class="figure">
<p><img src="../results/eda/interaction_plot.png" class="img-fluid figure-img"></p>
<figcaption>Number of rings (target variable) by shell weight (grams), grouped by Sex: Male (M), Female (F), and Infant (I). Linear regression lines for each group are shown.</figcaption>
</figure>
</div>
<p><strong>Observation</strong>: The relationship between shell weight and age appears roughly linear within each sex category, but the slopes differ—particularly for Infants, which show a steeper growth curve. This suggests that age-weight relationships may depend on developmental stage, supporting the inclusion of Sex as a feature in our models.</p>
</section>
</section>
<section id="model-selection-and-training" class="level3">
<h3 class="anchored" data-anchor-id="model-selection-and-training">6. Model Selection and Training</h3>
<section id="why-these-models" class="level4">
<h4 class="anchored" data-anchor-id="why-these-models">Why These Models?</h4>
<p>To address our research question—whether physical measurements can predict abalone age—we test three modeling approaches that span the complexity spectrum:</p>
<ol type="1">
<li><p><strong>Linear Regression (Baseline)</strong>: We start with linear regression because it provides an interpretable baseline. If a linear relationship exists between physical measurements and age, this model will capture it. The coefficients also help us understand which features contribute most to predicting age, which is valuable for biological interpretation.</p></li>
<li><p><strong>Random Forest Regressor</strong>: We include this ensemble method because biological growth patterns are often non-linear. Random Forest can capture complex interactions between features (e.g., the relationship between weight and age may differ for different shell sizes) without requiring us to manually specify these interactions.</p></li>
<li><p><strong>Support Vector Regression (SVR)</strong>: We test SVR with an RBF kernel as another non-linear approach. SVR is effective when relationships are complex but the number of features is moderate, as in our case.</p></li>
</ol>
</section>
<section id="evaluation-metrics" class="level4">
<h4 class="anchored" data-anchor-id="evaluation-metrics">Evaluation Metrics</h4>
<p>We evaluate models using two complementary metrics: - <strong>Root Mean Squared Error (RMSE)</strong>: Measures the average prediction error in the same units as the target (rings). Lower RMSE indicates better predictive accuracy. We use RMSE rather than MSE because it’s more interpretable—an RMSE of 2.0 means predictions are off by about 2 rings on average. - <strong>R² (Coefficient of Determination)</strong>: Represents the proportion of variance in the target explained by the model. R² = 1.0 means perfect prediction; R² = 0 means the model is no better than predicting the mean. This helps us understand how much of the age variation is captured by physical measurements.</p>
</section>
<section id="model-a-linear-regression-baseline" class="level4">
<h4 class="anchored" data-anchor-id="model-a-linear-regression-baseline">Model A: Linear Regression (Baseline)</h4>
<p>We construct a preprocessing pipeline that: 1. One-hot encodes the categorical Sex feature (to handle the three categories: M, F, I) 2. Standardizes numerical features (important for comparing coefficients) 3. Fits a Linear Regression model</p>
</section>
</section>
</section>
<section id="results" class="level2">
<h2 class="anchored" data-anchor-id="results">Results</h2>
<p>In this section, we present the results of our model training and evaluation. All models were trained exclusively on the training set, and evaluation metrics are computed on the held-out test set to ensure unbiased performance estimates.</p>
<section id="linear-regression-results" class="level3">
<h3 class="anchored" data-anchor-id="linear-regression-results">7. Linear Regression Results</h3>
<p>We evaluate the linear regression model by examining both quantitative metrics and visual diagnostics. The scatter plot below compares predicted vs.&nbsp;actual ring counts—points along the diagonal indicate accurate predictions.</p>
<div id="model_comp" class="quarto-figure quarto-figure-center anchored">
<figure class="figure">
<p><img src="../results/model/model_results_actual_vs_predicted.png" class="img-fluid figure-img"></p>
<figcaption>Actual Rings (x-axis) vs Predicted Rings (y-axis) for the linear regression model. The red dashed line represents perfect prediction (y = x). Points close to this line indicate accurate predictions, while deviations show prediction errors.</figcaption>
</figure>
</div>
</section>
</section>
<section id="this-figure-is-missing-from-the-results-folder.-the-one-above-is-not-correct.-should-be-figure-5." class="level1">
<h1>this figure is MISSING from the results folder. the one above is not correct. Should be figure 5.</h1>
<p><strong>Interpretation</strong>: The model tends to under-predict for older abalones (high ring counts) and shows considerable scatter throughout, consistent with the moderate R² value of ~0.44. This suggests that linear relationships alone cannot fully capture how age relates to physical measurements.</p>
<div id="tbl-linear_coefs" class="cell quarto-float quarto-figure quarto-figure-center anchored" data-execution_count="1">
<figure class="quarto-float quarto-float-tbl figure">
<figcaption class="quarto-float-caption-top quarto-float-caption quarto-float-tbl" id="tbl-linear_coefs-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Table&nbsp;1: Linear Regression coefficient values showing the estimated contribution of each feature to the predicted ring count after standardization and one-hot encoding.
</figcaption>
<div aria-describedby="tbl-linear_coefs-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<div class="cell-output cell-output-stdout">
<pre><code>this table is MISSING from the results folder.</code></pre>
</div>
</div>
</figure>
</div>
<p><strong>Interpretation</strong>: Since features are standardized, coefficient magnitudes are comparable. Whole weight shows the strongest positive association with age, while Shucked weight has a strong negative coefficient. This counterintuitive pattern (since both weights should increase with age) is likely due to multicollinearity among weight features—when correlated features are included together, their individual coefficients can be difficult to interpret. This further motivates our use of non-linear models that are less sensitive to multicollinearity.</p>
<section id="non-linear-model-results" class="level3">
<h3 class="anchored" data-anchor-id="non-linear-model-results">8. Non-Linear Model Results</h3>
<p>Given that the linear model explains only about 44% of the variance (R² ≈ 0.44), we now test non-linear models to see if they can capture more complex relationships in the data.</p>
<section id="model-b-random-forest-regressor" class="level4">
<h4 class="anchored" data-anchor-id="model-b-random-forest-regressor">Model B: Random Forest Regressor</h4>
<p>Random Forest builds multiple decision trees on bootstrapped samples and averages their predictions. This approach can capture non-linear patterns and feature interactions without overfitting. We use 100 trees with default hyperparameters as a reasonable starting point.</p>
</section>
<section id="model-c-support-vector-regression-svr" class="level4">
<h4 class="anchored" data-anchor-id="model-c-support-vector-regression-svr">Model C: Support Vector Regression (SVR)</h4>
<p>SVR with a Radial Basis Function (RBF) kernel maps the data into a higher-dimensional space where non-linear relationships become linear. This approach is particularly effective when the number of features is moderate. Note that feature scaling is critical for SVR performance, which is why we standardize all numeric features in our preprocessing pipeline.</p>
</section>
</section>
<section id="model-comparison" class="level3">
<h3 class="anchored" data-anchor-id="model-comparison">9. Model Comparison</h3>
<p>To determine which approach best addresses our research question, we compare all three models side-by-side using the same test set. This ensures a fair comparison since all models were trained on identical training data and evaluated on identical test data that was never seen during training.</p>
<div id="model_comp" class="quarto-figure quarto-figure-center anchored">
<figure class="figure">
<p><img src="../results/model/model_results_model_comparison.png" class="img-fluid figure-img"></p>
<figcaption>Side-by-side comparison of RMSE (lower is better) and R² (higher is better) across all three models evaluated on the test set.</figcaption>
</figure>
</div>
<p><strong>Key Finding</strong>: Both non-linear models (Random Forest and SVR) outperform the linear baseline, with SVR achieving the best performance (lowest RMSE of 2.17, highest R² of 0.52). This confirms that the relationship between physical measurements and abalone age contains non-linear components that simple linear regression cannot capture.</p>
</section>
<section id="discussion" class="level2">
<h2 class="anchored" data-anchor-id="discussion">Discussion</h2>
<p>In this report, we tested three different models to find which model was best at predicting the number of rings (as a proxy for age) of abalone molluscs. The baseline <strong>Linear Regression model</strong> explains about 44% of the variance in ring count (R² = 0.44) using size and weight measurements, with a root mean squared error (RMSE) of approximately <strong>2.34 rings</strong>. This means the model’s predictions are typically off by about 2.3 rings on average.</p>
<p>The other two models tested were non-linear approaches. The <strong>Random Forest model</strong> achieves higher R² (0.52) and lower RMSE (2.18 rings) than the linear baseline, demonstrating that abalone growth patterns are not purely linear in relation to physical features. The <strong>Support Vector Regression (SVR) with an RBF kernel</strong> shows the best performance among the three models, with an RMSE of 2.17 rings and R² of 0.52. Both non-linear models capture approximately 8% more variance than the linear model, confirming that physical measurements and age have non-linear relationships.</p>
<p>Although the linear model did not perform as well as the non-linear models, extracting the standardized coefficients reveals important patterns in our data. Whole Weight showed the strongest positive coefficient, while Shucked Weight had a strong negative coefficient. This counterintuitive pattern (since both weights should increase with age) indicates multicollinearity among the weight features—when highly correlated predictors are included together, their individual coefficients become difficult to interpret reliably. This observation further supports our use of non-linear models that are less sensitive to multicollinearity.</p>
<p>Within the context of biological organisms, that a linear regression model did not perform well is unsurprising. Growth rate, which impacts features such as those in our dataset, can be highly variable depending on biotic and abiotic factors. A linear regression model cannot capture enough of the variance present in the dataset. In a literature review by Guney et al.&nbsp;(2022), the authors reviewed six different predictive models of abalone age based on physical characteristics and found that the BPFFNN model had the highest test accuracy, followed by a random forest model <span class="citation" data-cites="ML_age_predict_paper">(<a href="#ref-ML_age_predict_paper" role="doc-biblioref">Guney et al. 2022</a>)</span>. This aligns with our findings that non-linear models outperform linear approaches.</p>
<p><strong>Practical Implications</strong>: Estimating abalone age in a non-destructive way is important for fisheries managers and aquaculture growers. Our results suggest that non-linear models using physical measurements can predict age with reasonable accuracy (±2.2 rings). However, with an R² of only 0.52, the models still leave about 48% of the variance unexplained. Future work could improve predictions by incorporating environmental features (e.g., water temperature, location), addressing multicollinearity through feature selection or regularization, and testing more sophisticated models such as neural networks.</p>
</section>
<section id="references" class="level2 unnumbered">


</section>
</section>

<div id="quarto-appendix" class="default"><section class="quarto-appendix-contents" role="doc-bibliography" id="quarto-bibliography"><h2 class="anchored quarto-appendix-heading">References</h2><div id="refs" class="references csl-bib-body hanging-indent" data-entry-spacing="0" role="list">
<div id="ref-ML_age_predict_paper" class="csl-entry" role="listitem">
Guney, Seda, Irem Kilinc, Alaa Ali Hameed, and Akhtar Jamil. 2022. <span>“Abalone Age Prediction Using Machine Learning.”</span> In <em>Pattern Recognition and Artificial Intelligence</em>, edited by Chawki Djeddi, Imran Siddiqi, Akhtar Jamil, Alaa Ali Hameed, and İsmail Kucuk, 329–38. Cham: Springer International Publishing.
</div>
<div id="ref-abalone_1" class="csl-entry" role="listitem">
Nash, Sellers, Warwick, and Wes Ford. 1994. <span>“<span>Abalone</span>.”</span> UCI Machine Learning Repository.
</div>
<div id="ref-pop_biol_paper" class="csl-entry" role="listitem">
Nash, Warwick, T. L. Sellers, S. R. Talbot, A. J. Cawthorn, and W. B. Ford. 1994. <span>“7he Population Biology of Abalone (_Haliotis_ Species) in Tasmania. I. Blacklip Abalone (_h. Rubra_) from the North Coast and Islands of Bass Strait.”</span> <em>Sea Fisheries Division, Technical Report No</em> 48 (January).
</div>
<div id="ref-python" class="csl-entry" role="listitem">
Python Core Team. 2025. <em><span class="nocase">Python: A dynamic, open source programming language</span></em>. <span>Python Software Foundation</span>. <a href="https://www.python.org/">https://www.python.org/</a>.
</div>
</div></section></div></main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
        const codeEl = trigger.previousElementSibling.cloneNode(true);
        for (const childEl of codeEl.children) {
          if (isCodeAnnotation(childEl)) {
            childEl.remove();
          }
        }
        return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp('/' + window.location.host + '/');
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->




</body></html>